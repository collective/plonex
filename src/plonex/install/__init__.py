from dataclasses import dataclass
from dataclasses import field
from datetime import datetime
from pathlib import Path
from pip_requirements_parser import RequirementsFile  # type: ignore
from plonex.base import BaseService
from rich.console import Console

import subprocess
import tomllib


@dataclass(kw_only=True)
class InstallService(BaseService):

    name: str = "install"
    dont_ask: bool = False

    etc_folder: Path = field(init=False)
    tmp_folder: Path = field(init=False)
    var_folder: Path = field(init=False)

    requirements_d_folder: Path = field(init=False)
    constraints_d_folder: Path = field(init=False)
    requirements_txt: Path = field(init=False)
    constrainst_txt: Path = field(init=False)

    def __post_init__(self):
        self.target = self._ensure_dir(self.target.absolute())
        self.etc_folder = self._ensure_dir(self.target / "etc")
        self.tmp_folder = self._ensure_dir(self.target / "tmp")
        self.var_folder = self._ensure_dir(self.target / "var")
        self.requirements_d_folder = self._ensure_dir(
            self.etc_folder / "requirements.d"
        )
        self.constraints_d_folder = self._ensure_dir(self.etc_folder / "constraints.d")

    @property
    def default_python(self):
        """Check with python executable is available"""
        if "python" in self.options:
            return self.options["python"]

        for python in ["python3", "python"]:
            which = subprocess.run(
                ["which", python],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                check=True,
            )
            if which.returncode == 0:
                return which.stdout.decode().strip()

    def ensure_virtualenv(self):
        """Ensure that we have a virtualenv"""
        if not (self.target / ".venv" / "bin" / "activate").exists():
            if self.options["python"] or self.dont_ask:
                python_path = self.default_python
            else:
                console = Console()
                python_path = (
                    console.input(
                        f"Please select the Python executable "
                        f"(default: {self.default_python}): "
                    )
                    or self.default_python
                )
            self.logger.info("Creating a virtualenv")
            subprocess.run(
                [str(python_path), "-m", "venv", str(self.target / ".venv")],
                check=True,
            )

        if not (self.virtualenv_dir / "bin" / "uv").exists():
            self.logger.info("Installing uv")
            subprocess.run(
                [
                    str(self.virtualenv_dir / "bin" / "pip"),
                    "install",
                    "uv",
                ],
                check=True,
            )

    @BaseService.entered_only
    def add_packages(self, packages: list):
        """Add a list of packages to the requirements"""
        now = datetime.now()
        time_marker = now.strftime("%Y%m%d-%H%M%S")
        lines = [
            "# Packages added by plonex install",
        ]
        lines.extend(sorted(packages))
        (self.requirements_d_folder / f"999-add-package-{time_marker}.txt").write_text(
            "\n".join(lines) + "\n"
        )

    @BaseService.entered_only
    def install_package(self, package: str):
        """Install a package in the virtualenv respecting the constraints"""
        self.ensure_virtualenv()
        self.logger.info("Installing %r", package)
        command = [
            str(self.virtualenv_dir / "bin" / "uv"),
            "pip",
            "install",
            package,
            "-c",
            str(self.constrainst_txt.absolute()),  # type: ignore
        ]
        subprocess.run(
            command,
            check=True,
        )

    def make_requirements_txt(self):
        """This will merge the requirements files in one big requirements.txt file"""
        lines = []
        for file in sorted(self.requirements_d_folder.iterdir()):
            lines.append(f"-r {file.absolute()}")
        self.requirements_txt = self.var_folder / "requirements.txt"
        with open(self.requirements_txt, "w") as file:
            file.write("# This file is generated by plonex\n")
            file.write("\n".join(lines))

    def resolve_package_name_from_path(self, requirement) -> str:
        """Resolve the package name from a path"""
        path = Path(requirement.link.path)

        pyproject_toml = path / "pyproject.toml"
        if pyproject_toml.exists():
            pyproject = tomllib.loads(pyproject_toml.read_text())

            try:
                return pyproject["project"]["name"]
            except KeyError:
                try:
                    return pyproject["tool"]["poetry"]["name"]
                except KeyError:
                    pass

        setup_cfg_path = path / "setup.cfg"
        if setup_cfg_path.exists():
            # This is deprecated
            from setuptools.config import read_configuration

            config = read_configuration(str(setup_cfg_path))
            try:
                return config["metadata"]["name"]
            except KeyError:
                pass

        return path.absolute().name

    def developed_packages(self):
        """Try to understand which packages are under development"""
        packages = set()
        for file in self.requirements_d_folder.iterdir():
            requirements = RequirementsFile.from_file(str(file), include_nested=True)
            editable_requirements = (
                requirement
                for requirement in requirements.requirements
                if requirement.is_editable
            )
            for requirement in editable_requirements:
                try:
                    name = self.resolve_package_name_from_path(requirement)
                except Exception as e:
                    name = requirement.link.filename
                    self.logger.warning(
                        "Could not resolve package name for requirement %r: %s",
                        requirement,
                        e,
                    )

                packages.add(name)

        return packages

    def make_constraints_txt(self):
        """Merge the constraints files in one big constraints.txt file"""
        included_files = []
        constraints = {}
        developed_packages = self.developed_packages()
        for file in self.constraints_d_folder.iterdir():
            requirements = RequirementsFile.from_file(str(file), include_nested=True)
            for requirement in requirements.requirements:
                if requirement.name not in developed_packages:
                    constraints[str(requirement.name), str(requirement.marker)] = (
                        requirement
                    )

        merged_constraints = included_files + [
            requirement.dumps() for _, requirement in sorted(constraints.items())
        ]

        self.constrainst_txt = self.var_folder / "constraints.txt"

        with open(self.constrainst_txt, "w") as file:
            file.write("# This file is generated by plonex\n")
            file.write("\n".join(merged_constraints))

    @property
    def command(self):
        return [
            str(self.virtualenv_dir / "bin" / "uv"),
            "pip",
            "install",
            "-r",
            str(self.requirements_txt.absolute()),
            "-c",
            str(self.constrainst_txt.absolute()),
        ]

    def __enter__(self):
        super().__enter__()
        self.ensure_virtualenv()
        self.make_requirements_txt()
        self.make_constraints_txt()
        return self

    @BaseService.entered_only
    def run(self, save_constraints: bool = False):
        # Check if we have a virtualenv and if not create one
        self.ensure_virtualenv()
        super().run()
        # Run pip freeze and compare the output with the constraints
        # to see if we are missing something
        self.logger.debug("Checking if all constraints are met")

        constraints = RequirementsFile.from_file(self.constrainst_txt).requirements
        installed = subprocess.run(
            [str(self.virtualenv_dir / "bin" / "pip"), "freeze"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        ).stdout.decode()

        # Save the installed packages to a temporary file
        with open(self.tmp_folder / "installed.txt", "w") as file:  # type: ignore
            file.write(installed)

        installed = RequirementsFile.from_file(file.name).requirements

        # XXX: This is an hack because the parser
        # does not return normalized package names
        missing = {req.dumps().lower().replace("_", "-") for req in installed} - {  # type: ignore  # noqa:E501
            req.dumps().lower().replace("_", "-") for req in constraints
        }

        missing = {req for req in missing if not req.startswith("--editable")}

        if missing:
            if save_constraints:
                now = datetime.now().strftime("%Y%m%d-%H%M%S")
                autoinstalled_file = (
                    self.target
                    / "etc"
                    / "constraints.d"
                    / f"999-{now}-autoinstalled.txt"
                )
                if autoinstalled_file.exists():
                    missing |= set(autoinstalled_file.read_text().splitlines())
                    self.logger.info(f"Adding new constraints to {autoinstalled_file}")
                autoinstalled_file.write_text("\n".join(sorted(missing)) + "\n")
            else:
                self.logger.warning(f"Missing constraints: {sorted(missing)}")
                console = Console()
                console.print(
                    f"You may want to add the following constraints to a file "
                    f"in the {self.constraints_d_folder}:"
                )
                console.print(*sorted(missing), sep="\n")
                console.print(
                    "Running  `plonex dependencies --persist` will do that for you."
                )
